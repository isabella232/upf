# LP Control Ports
create_logic_port lp_lSleep
create_logic_port lp_rSleep
create_logic_port lp_lReady
create_logic_port lp_rReady

create_logic_port lp_lSleepCpu0
create_logic_port lp_lSleepCpu1
create_logic_port lp_rSleepCpu0
create_logic_port lp_rSleepCpu1
create_logic_port lp_lRetCpu0
create_logic_port lp_lRetCpu1
create_logic_port lp_rRetCpu0
create_logic_port lp_rRetCpu1
create_logic_port lp_lReadyCpu0
create_logic_port lp_lReadyCpu1

create_logic_port lp_rReadyCpu0
create_logic_port lp_rReadyCpu1
create_logic_port lp_isoCpu0
create_logic_port lp_isoCpu1

# Connect lower level controls
# The control nets to the lower level CPU macro are connected
connect_logic_net lp_lSleepCpu0 -ports u_cpu0/lp_lSleep
connect_logic_net lp_lSleepCpu1 -ports u_cpu1/lp_lSleep
connect_logic_net lp_rSleepCpu0 -ports u_cpu0/lp_rSleep
connect_logic_net lp_rSleepCpu1 -ports u_cpu1/lp_rSleep
connect_logic_net lp_lReadyCpu0 -ports u_cpu0/lp_lReady
connect_logic_net lp_lReadyCpu1 -ports u_cpu1/lp_lReady
connect_logic_net lp_rReadyCpu0 -ports u_cpu0/lp_rReady
connect_logic_net lp_rReadyCpu1 -ports u_cpu1/lp_rReady
connect_logic_net lp_lRetCpu0   -ports u_cpu0/lp_lRet
connect_logic_net lp_lRetCpu1   -ports u_cpu1/lp_lRet
connect_logic_net lp_rRetCpu0   -ports u_cpu0/lp_rRet
connect_logic_net lp_rRetCpu1   -ports u_cpu1/lp_rRet

# Design attribute UPF_is_soft_macro is set on cpu0 and cpu1 instance to
# enable the correct terminal boundary condition as the CPU has been
# hardened in the implementation.
# In the verification context, if the actual drivers and receivers
# across the port are available, the port attributes defined in the
# terminal boundary shall be ignored.
set_design_attributes -model {cpu} –is_soft_macro TRUE

# Retention Strategy
# From the SoC functional power states, MPCORE is configured to NOT
# use RET state defined in constraint UPF for the logic.
# The memories can be in retention state when MPCORE is in ON state.
# The RET state of PDMPCORE is defined as illegal in this
# configuration of the MPCORE.
add_power_state -domain PDMPCORE -update \
  -state {RET -illegal}

# The PDMPCORE.ret supply set is associated to PDMPCORE.primary since the
# ON and OFF power states of PDMPCORE power domain have been defined as
# a function of PDMPCORE.ret in addition to PDMPCORE.primary
associate_supply_set { PDMPCORE.primary PDMPCORE.ret }

# Memory Related Configuration
# List of memory instances in MPCORE
set l2MemInstances [list \
  u_l2tag_ram \
  u_l2data_ram \
]

# Two new supply set handles mem_vddc and mem_vddp are updated to
# PDMPCORE. mem_vddc will be associated to
# VDDCE of all the memories and mem_vddp will be associated to VDDPE
# of all the memories in the CPU.
create_power_domain PDMCORE -update \
  -supply {mem_vddc} \
  -supply {mem_vddp}

# Similar to the L1 memories in CPU configuration UPF, the power
# model for L2 memory is applied.
# Create a group of macros that should be in the same state
# at any given time.

# Apply power model to each macro instance
apply_power_model memPwrModel2 -elements $l2MemInstances \
  -supply_map {{ss_vddpe PDMPCORE.mem_vddp} \
               {ss_vddce PDMPCORE.mem_vddc}}

# When MPCORE is in OFF state, all memories shall be in OFF state.
# When MPCORECPU is in RET state, all memories shall be in RET state.
# When MPCORE is in ON state, memories can be in ON or OFF state but
# all memories shall be in the same state.
# To enforce power state over a collection of lower level instances,
# create a group and set power state of the group based on the
# power state of the lower level instances.
create_power_state_group L2MEMS

# Create power states for the group created.
# Power state of the group is such that each of the instance
# in the group are in the same power state as the group itself.
add_power_state -group L2MEMS \
  -state {ON -logic_expr {u_l2tag_ram==ON && u_l2data_ram==ON }} \
  -state {OFF -logic_expr {u_l2tag_ram==OFF && u_l2data_ram==OFF}}

# Update power state of PDMPCORE with the power state of the group
# when MPCORE is in ON state, L2MEMS can be in ON/OFF state.
# It is illegal for L2MEMS to be in NOT OFF state when MPCORE is OFF.
add_power_state -domain PDMPCORE -update \
  -state {ERR1 -logic_expr {PDMPCORE==OFF && L2MEMS!=OFF} -illegal}

# Power State logic_expr update for Supply Sets
# The logic expression that defines the ON and OFF state of the
# supply set is updated.
# ON and OFF state are deferred power states that are now being
# updated. Since the deferred power states are being updated -update
# is required.
add_power_state -supply PDMPCORE.primary -update \
  -state {ON -logic_expr {lp_lSleep==1}}\
  -state {OFF -logic_expr {lp_lSleep==0}}

# The supplies support nominal, over-drive, under-drive voltage conditions
# NOM, OD, UD are refined power states of ON state

add_power_state -supply PDMPCORE.primary -update \
  -state {ON.NOM -logic_expr {dynControl == 2’b00}}\
  -state {ON.OD  -logic_expr {dynControl == 2’b01}}\
  -state {ON.UD  -logic_expr {dynControl == 2’b10}}

# Isolation Policy for paths that have CPU as source
# The port attributes specified in the CPU constraint UPF determine
# the clamp value for the ports.
set_isolation isoCpu0ToMpcore \
  -domain PDMPCORE \
  -applies_to inputs \
  -source u_cpu0/PDCPU.primary \
  -isolation_signal lp_isoCpu0 \
  -isolation_sense low

set_isolation isoCpu1ToMpcore \
  -domain PDMPCORE \
  -applies_to inputs \
  -source u_cpu1/PDCPU.primary \
  -isolation_signal lp_isoCpu1 \
  -isolation_sense low
